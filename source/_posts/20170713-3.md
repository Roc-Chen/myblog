---
title: vue2.0生命周期简述
comments: true
tags: vue
categories: 技术博客
description: vue现在无疑是非常火的前端技术之一，我本人也用vue做过一些项目，开发起来确实爽，但难免会有一些坑，之后我会分享一些坑。今天就先谈谈vue2.0的生命周期，这个比较基础，网上也有很多关于这个的文章，谨供参考。
---
vue现在无疑是非常火的前端技术之一，我本人也用vue做过一些项目，开发起来确实爽，但难免会有一些坑，之后我会分享一些坑。今天就先谈谈vue2.0的生命周期，这个比较基础，网上也有很多关于这个的文章，谨供参考。
首先还是先上图说明：
![vue](/img/article/20170713/1-1.png "vue2.0生命周期图")
相信大家看到这个图就已经很清晰了，下面做一些简单的说明，大致顺序如下：
1.创建Vue实例，new Vue()。
2.初始化数据，在此之前，有一个beforeCreate钩子被调用。
3.创建数据监测、内部事件初始化。
4.数据初始化完成，created钩子被调用。
5.找到组件的挂载位置：如果Vue实例中包含有声明的el属性值，那么el的值就是组件的挂载点。否则调用Vue的$mount方法对组件进行手动挂载，$mount的参数就是组件要挂载的节点的选择器。
6.检查组件是否有template模块，如果没有，那么直接编译挂载点的内容；如果有，将之前初始化的数据和template内容进行组装编译，产生一段完整的html内容
7.接下来要将产出的html对el挂载点的内容进行替换，但在此之前beforeMounte钩子要被调用。
8.将挂载点的内容替换成之前产出的html内容。此时文档当中才真正呈现template中包含的内容。
9.调用mounted钩子。如果有节点操作和服务端数据请求应该放在mounted钩子里。
10.服务端请求的数据返回后要执行数据集的更新，准备重新渲染DOM节点，调用beforeUpdate钩子，如果要对结果集进行进一步的处理，在这个钩子里处理是最佳时机，因为它不会导致重复渲染，不会影响性能 。
11.重新渲染DOM节点。
12.节点渲染完成，调用updated钩子。注意：在updated钩子里不应该再更改数据状态，因为在这里更改数据状态会导致节点无限循环渲染，导致内存泄漏。
13.如果调用了Vue实例的$destroy方法，先调用beforeDestroy钩子。
14.Vue实例的所有绑定的东西都要被解除，包括数据观测和事件监听器，子实例也会随之被销毁。
15.调用destroyed钩子。至此，一个Vue实例就走完了它的一生！





















